use std::{fs, path::Path};

use itertools::Itertools;
use pulldown_cmark_toc::{HeadingLevel, TableOfContents};
use snapbox;

fn repo_root_path() -> &'static Path {
    Path::new("../../../")
}

#[test]
fn authors_are_not_duplicate() {
    let authors_path = repo_root_path().join("AUTHORS");
    let authors = fs::read_to_string(&authors_path).unwrap();
    let authors_deduplicated = authors.split('\n').unique().join("\n");
    snapbox::assert_eq_path(authors_path, authors_deduplicated);
}

#[test]
fn markdown_tocs_are_up_to_date() {
    let md_paths = include_str!("../md_files_with_a_toc.txt")
        .trim()
        .split("\n");

    const START_MARKER: &str = "<!-- START autogenerated TOC -->\n";
    const DONT_EDIT: &str = "<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN cargo update-md-toc -->\n";
    const END_MARKER: &str = "<!-- END autogenerated TOC -->";

    for path in md_paths {
        let full_path = repo_root_path().join(path);

        let text = fs::read_to_string(&full_path).unwrap();
        let toc = TableOfContents::new(&text).to_cmark_with_options(
            pulldown_cmark_toc::Options::default().levels(HeadingLevel::H2..=HeadingLevel::H6),
        );

        let before = text
            .split_once(START_MARKER)
            .unwrap_or_else(|| panic!("expected `{START_MARKER}` in {:?}", path))
            .0;
        let after = text
            .split_once(END_MARKER)
            .unwrap_or_else(|| panic!("expected `{END_MARKER}` in {:?}", path))
            .1;

        snapbox::assert_eq_path(
            full_path,
            format!("{before}{START_MARKER}{DONT_EDIT}{toc}{END_MARKER}{after}"),
        )
    }
}
